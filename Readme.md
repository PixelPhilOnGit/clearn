# 编译c代码&反汇编

```shell
# 生成hello.o 文件
gcc -g -c hello.c
# 反汇编
objdump -d hello.o

# 清楚看到每行c代码对应哪些汇编指令
objdump -d -S hello.o

# 查看对应生产商指令
objdump -d -S -M intel hello.o
```

# CPU中程序员最关心的部分
  - 控制器
  - 寄存器
  - 运算器

# cpu指令集
不同架构指令不同

## 怎么查看对应操作系统的指令集
```shell
# 1. windows查看命令
systeminfo

# 2. linux查看指令
lscpu
```

## 指令
有的操作码需要跟操作数，有的不需要
```
操作码       操作数        功能
mov           A，B       将B的值赋值给A
add           A, B       将A和B的值相加，并将结果赋给A
push          A          将A的值存储在栈中
pop           A          从栈中读取出值，并将其赋给A
call          A          调用函数A
ret           无
cmp           A, B       比较指令，指令执行完成后，Pc条件码寄存器会自动开始执行下一条指令
jne           A          jump if not equal, 
jmp           A          无条件跳转指令
jle           A          看条件寄存器0标识符是true还是false, true就跳到A指令行，       
```

## 寄存器rdp, rsp，条件码寄存器

```
rbp(register base pointer): 栈基址寄存器（栈帧指针），指向当前栈帧的栈底地址
rsp(register stack pointer): 栈顶寄存器(栈指针)，指向栈顶元素
条件码寄存器： 比较结果存到这里
```


# 操作系统

## 操作系统的作用

```
为上层应用程序提供服务，使得上层应用程序不用考虑底层的很琐碎的硬件操作

操作系统os统一和硬件交互

应用程序不能直接访问硬件资源，除了操作系统，
由操作系统统一管理

对上面的应用程序提供抽象接口
应用程序可以很方便的访问操作系统提供的接口

```

## 操作系统的内部组件

`程序员或者应用程序一般直接操作内核`
- linux shell 或 windows界面 【外壳】
- kernel(内核)： CPU管理，内存管理，磁盘管理，中断管理（IO设备驱动等）

## 操作系统启动流程
说明：
    每一种操作系统的启动细节都不一样
    但是，不同的操作系统的大体启动流程都是差不多的
一般操作系统的大体启动流程（真实的非常复杂）

### 前置知识
 1. 操作系统程序实现存放在磁盘中
 2. BootLoader: 将磁盘中的OS加载到内存
 3. BIOS(Basic IO System): 提供开机支持工作，固定在主板的ROM(Read Only Memory)区域


 ### 流程
  1. CPU 执行BIOS指令
  2. BIOS将BootLoader加载到内存中
  3. CPU执行BootLoader中的指令
  4. BootLoader将Os加载到内存中
  5. CPU执行OS的指令


# 内核态 & 用户态
- 用户态(用户接口程序，各种应用): 只能执行一部分机器指令，对于那些会影响机器的控制或者可进行IO操作的指令，在用户态中的程序中是禁止的

- 内核态（操作系统）：可以完全访问所有的硬件，也可以执行机器能够运行的任何指令


***应用程序通过系统调用调用操作系统***



